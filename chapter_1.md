# **Для начала:**
1.  Установим python3 последней версии [тут](https://www.python.org/downloads/ "тут").  (при установке надо указать add to patsh).
2. Будем работать в любом редакторе кода, например, [pyCharm](https://www.jetbrains.com/pycharm/ "pyCharm") (который я использую).
3. Создаём новый проект site-book.

------------


# **Подготовка к проекту:**
1. Скачиваем библиотеку [Django](https://www.djangoproject.com "Django")
`pip install django`.
2. Для создания проекта нам в дериктории проекта надо прописать.
` django-admin startproject book`
Django создаёт дерево файлов:
```
└── book
	├── manage.py
	└── book
		├── __init__.py
	├── settings.py
	├── urls.py
	└── wsgi.py
```
3. Перейдём в папку book, и выполним `python manage.py runserver` для запуска сервера
По умолчанию сайт открывается по ссылке http://127.0.0.1:8000/
![](http://i.imgur.com/CkdqMWTg.png)
4.  **Структура проекта**:
**settings.py** контролирует настройки нашего проекта, 
**urls.py** сообщает Django, какие страницы создать в ответ на запрос браузера или URL-адреса
**wsgi.py** помогает Django обслуживать наши возможные веб-страницы.
**manage.py** используется для выполнения различных команд Django, таких как запуск локальной сети  или создание нового приложения.
5.  Django использует концепцию проектов и приложений для поддержания чистоты и читаемости кода. Один проект Django содержит одно или несколько приложений, которые работают вместе. 
Например, у реального Django  e-commerce site может быть одно приложение
для аутентификации пользователя, другое приложение для платежей и третье приложение для редактирование товаров.
6. Нам нужно создать ваше первое приложение, которое мы будем называть **admin**
`python manage.py startapp admin`
Структура теперь выглядит так.
```
── admin
	├── __init__.py
	├── admin.py
	├── apps.py
	├── migrations
		└── __init__.py
	├── models.py
	├── tests.py
	└── views.py
```

7. Давайте рассмотрим, что делает каждый новый файл приложения:
admin.py - это файл конфигурации для встроенного приложения администратора Django
**apps.py** - это файл конфигурации для самого приложения.
переносит / отслеживает любые изменения в нашем файле models.py, поэтому наша база данных и models.py оставаться в синхронизации
**models.py** - это место, где мы определяем наши модели баз данных, которые Django автоматически
переводит в таблицы базы данных
**tests.py** для наших тестов для конкретных приложений
**views.py** - это место, где мы обрабатываем логику запроса / ответа для нашего веб-приложения.
8. Хотя наше новое приложение существует в проекте Django, Django не «знает»
об этом, пока мы явно не добавим его. В вашем текстовом редакторе откройте файл settings.py и
прокрутите вниз до INSTALLED_APPS, где вы увидите уже шесть встроенных приложений Django.
Добавьте наше новое приложение страниц вверху:
```python
# book/settings.py
INSTALLED_APPS = [
	'admin.apps.AdminConfig', # new
	'django.contrib.admin',
	'django.contrib.auth',
	'django.contrib.contenttypes',
	'django.contrib.sessions',
	'django.contrib.messages',
	'django.contrib.staticfiles',
]
```
9. В Django представления определяют, какой контент отображается на данной странице, в то время как URLConfs определит, куда идет этот контент.
Когда пользователь запрашивает определенную страницу, например домашнюю страницу, URLConf использует обычное выражение для сопоставления этого запроса с соответствующей функцией просмотра, которая затем возвращает
правильные данные.
Другими словами, наше представление выведет текст «Hello, Admin», а наш URL-адрес обеспечит, что когда пользователь заходит на домашнюю страницу, он перенаправляется на правильный экран.
Порядок заданного цикла HTTP-запроса / ответа. Когда вы вводите URL, такие
как google.com первое, что происходит в нашем Django
В проекте обнаружен URL-паттерн, соответствующий домашней странице. URLpattern определяет представление, которое затем определяет содержимое страницы (обычно из базы данных).
и шаблон для укладки. Конечный результат отправляется обратно пользователю в виде HTTP-ответа.
Начнем с обновления файла **views.py** в нашем приложении страниц, чтобы он выглядел следующим образом:
```python
# admin/views.py
from django.http import HttpResponse
def homePageView(request):
	return HttpResponse('Hello, World!')
```
По сути, мы говорим, что когда вызывается функция view homePageView, возвращаем
текст «Привет, мир!» Более конкретно, мы импортировали встроенный HttpResponse
метод, чтобы мы могли вернуть объект ответа пользователю. Мы создали функцию под названием homePageView, который принимает объект запроса и возвращает ответ со строкой
Привет, мир!.
10.  Теперь нам нужно настроить наши URL. В приложении страниц создайте новый файл urls.py
Затем обновите его следующим кодом:
```python
# admin/urls.py
from django.urls import path
from .views import homePageView
urlpatterns = [
		path('', homePageView, name='home')
]
```
В верхней строке мы импортируем путь из Django для включения нашего URLpattern и далее.
На следующей строке мы импортируем наши взгляды. Используя период .views мы ссылаемся на текущий каталог, который является нашим приложением страниц, содержащим и views.py и urls.py. наш
URLpattern состоит из трех частей:
	- регулярное выражение Python для пустой строки ''
	- указать вид, который называется homePageView
	- добавить необязательный URL-адрес 'home'
Другими словами, если пользователь запрашивает домашнюю страницу, представленную пустой строкой
'' тогда используйте представление, названное homePageView.
Мы почти закончили. Последний шаг - это настроить наш файл уровня проекта urls.py, так как он
Принято использовать несколько приложений в одном проекте Django, поэтому каждому из них необходимо
собственный маршрут.
11.  «Уровень проекта» означает самый верхний, родительский каталог приложения. В этом случае
где существуют папки book. Как только мы находимся внутри
конкретное приложение мы на уровне приложения.
Обновите файл book/urls.py следующим образом:
```python
# book/urls.py
from django.contrib import admin
from django.urls import path, include
urlpatterns = [
		 path('admin/', admin.site.urls),
		 path('new_admin_panel', include('admin.urls')),
]
```
Мы импортировали include во второй строке рядом с path, а затем создали новый
URLpattern для нашего приложения страниц. Теперь каждый раз, когда пользователь посещает домашнюю страницу в / они
сначала будет перенаправлен в приложение страниц, а затем в представление homePageView.
мы называем это в нашем URLpattern как pages.urls. Причина, по которой мы делаем это таким образом, заключается в том, что
что метод django.urls.include () ожидает, что мы передадим модуль или приложение в качестве
Первый аргумент. Таким образом, без использования include мы должны импортировать наше приложение страниц, но
так как мы используем включить, нам не нужно на уровне проекта
Запустим сервер `python manage.py runserver`

------------

